---
alwaysApply: false
---
Description: Dockerを使って、開発環境や本番環境用のコンテナイメージを構築する際のベストプラクティスを定義します。Dockerfileの作成・編集に関する質問があった場合に適用してください。

# 1. イメージはできるだけ小さく保つ
- **考え方**: イメージサイズが小さいと、ビルドやデプロイが高速になり、ストレージを節約できます。また、不要なライブラリやツールが含まれないため、セキュリティリスクも低減します。
- **AIへの指示**: 「このDockerfile、もっとイメージサイズを小さくするにはどうすればいいかな？改善点を教えて。」

# 2. `.dockerignore` を活用する
- **考え方**: `COPY . .` のような命令を実行する際、`.dockerignore`ファイルに記述されたファイルやフォルダは、Dockerのビルドコンテキストから除外されます。`node_modules`や`.git`、ログファイルなど、イメージに含めるべきでないものを指定することで、ビルドを高速化し、不要な情報がイメージに含まれるのを防ぎます。
- **AIへの指示**: 「Node.jsプロジェクト用の、一般的な`.dockerignore`ファイルの内容を生成してほしい。」

# 3. マルチステージビルドで本番用イメージを最適化する
- **考え方**: 開発時には多くのツール（TypeScript, ESLint, テストライブラリなど）が必要ですが、本番環境で実際にアプリケーションを動かすのにこれらは不要です。マルチステージビルドを使い、ビルド用のステージと、実行用のステージを分けることで、本番用イメージには本当に必要なファイルだけを含めることができます。
- **実践方法**:
    ```Dockerfile
    # ステージ1: ビルド環境
    FROM node:20-alpine AS builder
    WORKDIR /app
    COPY package*.json ./
    RUN npm install
    COPY . .
    RUN npm run build

    # ステージ2: 本番環境
    FROM node:20-alpine
    WORKDIR /app
    COPY --from=builder /app/package*.json ./
    COPY --from=builder /app/node_modules ./node_modules
    COPY --from=builder /app/dist ./dist
    CMD [ "node", "dist/main.js" ]
    ```
- **AIへの指示**: 「このNext.jsアプリケーション用のDockerfileを、マルチステージビルドを使って本番用に最適化してほしい。」

# 4. ベースイメージは具体的なバージョンを指定する
- **考え方**: `node:latest`のようなタグを使うと、いつの間にかメジャーバージョンが変わり、ビルドが失敗する原因になります。`node:20-alpine`のように、バージョンと種類（`alpine`は軽量版）を明記することで、誰がいつビルドしても同じ結果になる「再現性」を担保します。
- **AIへの指示**: 「このPythonアプリのベースイメージ、`python:3.11-slim`と`python:3.11`ではどう違うの？どちらがおすすめ？」

# 5. rootユーザーで実行しない
- **考え方**: デフォルトでは、コンテナ内のプロセスはrootユーザーで実行されます。これはセキュリティ上のリスクです。専用のユーザーを作成し、そのユーザーでアプリケーションを実行するようにしましょう。
- **実践方法**:
    ```Dockerfile
    # ... (前略)
    RUN addgroup -S appgroup && adduser -S appuser -G appgroup
    USER appuser
    CMD [ "node", "dist/main.js" ]
    ```
- **AIへの指示**: 「このDockerfileの最後に、セキュリティを考慮して、root以外の一般ユーザーでプロセスを実行するような設定を追加してほしい。」

# 6. コンテナの健康管理 (Healthcheck)
- **考え方**: コンテナが「起動している」ことと「正常に動作している」ことは別物です。プロセスは生きていても、DB接続が切れていたり、デッドロックしている可能性があります。`HEALTHCHECK`命令を使って、コンテナの状態を外部（Dockerやオーケストレーター）に正しく伝えましょう。
- **実践方法**:
    ```Dockerfile
    # 30秒ごとに確認、タイムアウト10秒、失敗3回で不健康とみなす
    HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
      CMD curl -f http://localhost:3000/health || exit 1
    ```
- **AIへの指示**: 「このAPIサーバー用のDockerfileに、`/health`エンドポイントを叩くヘルスチェックを追加して。」

# 7. 脆弱性スキャン (Vulnerability Scanning)
- **考え方**: コンテナイメージには、OSパッケージやライブラリの脆弱性が含まれている可能性があります。Trivyなどのスキャナーを使って定期的にイメージをチェックし、既知の脆弱性を排除しましょう。
- **AIへの指示**: 「Trivyを使って、今ビルドしたDockerイメージの脆弱性をスキャンするコマンドを教えて。」